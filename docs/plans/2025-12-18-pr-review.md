# PR Review Feature Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add `--pr-review` flag that generates annotated markdown optimized for AI-assisted PR review.

**Architecture:** New `pr.py` module handles git branch comparison and diff generation. CLI gets `--pr-review [TARGET]` argument. Output includes annotated sections (summary, diff, full files) so ChatGPT understands the context.

**Tech Stack:** Git subprocess commands, existing scope/core modules, markdown generation.

---

## Task 1: Add PR Module with Branch Detection

**Files:**
- Create: `src/repo2ai/pr.py`
- Create: `tests/test_pr.py`

**Step 1: Write the failing test**

```python
# tests/test_pr.py
"""Tests for PR review functionality."""

import subprocess
import tempfile
from pathlib import Path
from unittest import TestCase

from repo2ai.pr import get_target_branch


class TestTargetBranchDetection(TestCase):
    """Test target branch detection logic."""

    def setUp(self):
        """Create a temporary git repository."""
        self.temp_dir = tempfile.mkdtemp()
        self.repo_root = Path(self.temp_dir)

        # Initialize git repo with main branch
        subprocess.run(["git", "init", "-b", "main"], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "config", "user.email", "test@test.com"],
            cwd=self.repo_root,
            capture_output=True,
        )
        subprocess.run(
            ["git", "config", "user.name", "Test"],
            cwd=self.repo_root,
            capture_output=True,
        )

        # Create initial commit on main
        (self.repo_root / "file.txt").write_text("initial")
        subprocess.run(["git", "add", "."], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "Initial commit"],
            cwd=self.repo_root,
            capture_output=True,
        )

    def tearDown(self):
        """Clean up temporary directory."""
        import shutil
        shutil.rmtree(self.temp_dir)

    def test_explicit_target_used(self):
        """Test that explicit target overrides detection."""
        result = get_target_branch(self.repo_root, explicit_target="develop")
        self.assertEqual(result, "develop")

    def test_fallback_to_main(self):
        """Test fallback to main when no upstream."""
        # Create feature branch without upstream
        subprocess.run(
            ["git", "checkout", "-b", "feature"],
            cwd=self.repo_root,
            capture_output=True,
        )

        result = get_target_branch(self.repo_root, explicit_target=None)
        self.assertEqual(result, "main")
```

**Step 2: Run test to verify it fails**

Run: `poetry run pytest tests/test_pr.py::TestTargetBranchDetection::test_explicit_target_used -v`
Expected: FAIL with "No module named 'repo2ai.pr'"

**Step 3: Write minimal implementation**

```python
# src/repo2ai/pr.py
"""PR review functionality for generating AI-friendly PR context."""

import subprocess
from pathlib import Path
from typing import Optional


def get_target_branch(
    repo_root: Path,
    explicit_target: Optional[str] = None,
) -> str:
    """
    Determine the target branch for PR comparison.

    Priority:
    1. Explicit target if provided
    2. Upstream tracking branch if set
    3. Fallback to 'main'

    Args:
        repo_root: Path to repository root
        explicit_target: User-specified target branch

    Returns:
        Target branch name
    """
    if explicit_target:
        return explicit_target

    # Try to get upstream tracking branch
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{upstream}"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True,
        )
        upstream = result.stdout.strip()
        if upstream:
            # Extract branch name from origin/branch format
            if "/" in upstream:
                return upstream.split("/", 1)[1]
            return upstream
    except subprocess.CalledProcessError:
        pass

    return "main"
```

**Step 4: Run test to verify it passes**

Run: `poetry run pytest tests/test_pr.py::TestTargetBranchDetection -v`
Expected: PASS

**Step 5: Commit**

Skip (user will commit at end)

---

## Task 2: Add Diff Generation

**Files:**
- Modify: `src/repo2ai/pr.py`
- Modify: `tests/test_pr.py`

**Step 1: Write the failing test**

Add to `tests/test_pr.py`:

```python
from repo2ai.pr import get_target_branch, get_branch_diff


class TestDiffGeneration(TestCase):
    """Test diff generation between branches."""

    def setUp(self):
        """Create a temporary git repository with branches."""
        self.temp_dir = tempfile.mkdtemp()
        self.repo_root = Path(self.temp_dir)

        # Initialize git repo
        subprocess.run(["git", "init", "-b", "main"], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "config", "user.email", "test@test.com"],
            cwd=self.repo_root,
            capture_output=True,
        )
        subprocess.run(
            ["git", "config", "user.name", "Test"],
            cwd=self.repo_root,
            capture_output=True,
        )

        # Create initial commit on main
        (self.repo_root / "existing.py").write_text("# existing\n")
        subprocess.run(["git", "add", "."], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "Initial commit"],
            cwd=self.repo_root,
            capture_output=True,
        )

        # Create feature branch with changes
        subprocess.run(
            ["git", "checkout", "-b", "feature"],
            cwd=self.repo_root,
            capture_output=True,
        )
        (self.repo_root / "existing.py").write_text("# existing\n# modified\n")
        (self.repo_root / "new_file.py").write_text("# new file\n")
        subprocess.run(["git", "add", "."], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "Feature changes"],
            cwd=self.repo_root,
            capture_output=True,
        )

    def tearDown(self):
        """Clean up temporary directory."""
        import shutil
        shutil.rmtree(self.temp_dir)

    def test_get_branch_diff(self):
        """Test getting diff between branches."""
        diff = get_branch_diff(self.repo_root, "main")

        self.assertIn("+# modified", diff)
        self.assertIn("new_file.py", diff)

    def test_diff_empty_when_same(self):
        """Test empty diff when branches are same."""
        subprocess.run(
            ["git", "checkout", "main"],
            cwd=self.repo_root,
            capture_output=True,
        )

        diff = get_branch_diff(self.repo_root, "main")
        self.assertEqual(diff, "")
```

**Step 2: Run test to verify it fails**

Run: `poetry run pytest tests/test_pr.py::TestDiffGeneration::test_get_branch_diff -v`
Expected: FAIL with "cannot import name 'get_branch_diff'"

**Step 3: Write minimal implementation**

Add to `src/repo2ai/pr.py`:

```python
def get_branch_diff(
    repo_root: Path,
    target_branch: str,
) -> str:
    """
    Get the diff between current branch and target branch.

    Args:
        repo_root: Path to repository root
        target_branch: Branch to compare against

    Returns:
        Unified diff string
    """
    try:
        result = subprocess.run(
            ["git", "diff", f"{target_branch}...HEAD"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return ""
```

**Step 4: Run test to verify it passes**

Run: `poetry run pytest tests/test_pr.py::TestDiffGeneration -v`
Expected: PASS

---

## Task 3: Add Changed Files List

**Files:**
- Modify: `src/repo2ai/pr.py`
- Modify: `tests/test_pr.py`

**Step 1: Write the failing test**

Add to `tests/test_pr.py`:

```python
from repo2ai.pr import get_target_branch, get_branch_diff, get_changed_files


class TestChangedFiles(TestCase):
    """Test changed files detection."""

    def setUp(self):
        """Create a temporary git repository with branches."""
        self.temp_dir = tempfile.mkdtemp()
        self.repo_root = Path(self.temp_dir)

        # Initialize git repo
        subprocess.run(["git", "init", "-b", "main"], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "config", "user.email", "test@test.com"],
            cwd=self.repo_root,
            capture_output=True,
        )
        subprocess.run(
            ["git", "config", "user.name", "Test"],
            cwd=self.repo_root,
            capture_output=True,
        )

        # Create initial commit on main
        (self.repo_root / "existing.py").write_text("# existing\n")
        (self.repo_root / "unchanged.py").write_text("# unchanged\n")
        subprocess.run(["git", "add", "."], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "Initial commit"],
            cwd=self.repo_root,
            capture_output=True,
        )

        # Create feature branch with changes
        subprocess.run(
            ["git", "checkout", "-b", "feature"],
            cwd=self.repo_root,
            capture_output=True,
        )
        (self.repo_root / "existing.py").write_text("# existing\n# modified\n")
        (self.repo_root / "new_file.py").write_text("# new file\n")
        subprocess.run(["git", "add", "."], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "Feature changes"],
            cwd=self.repo_root,
            capture_output=True,
        )

    def tearDown(self):
        """Clean up temporary directory."""
        import shutil
        shutil.rmtree(self.temp_dir)

    def test_get_changed_files(self):
        """Test getting list of changed files."""
        files = get_changed_files(self.repo_root, "main")

        self.assertEqual(len(files), 2)
        self.assertIn(self.repo_root / "existing.py", files)
        self.assertIn(self.repo_root / "new_file.py", files)
        self.assertNotIn(self.repo_root / "unchanged.py", files)
```

**Step 2: Run test to verify it fails**

Run: `poetry run pytest tests/test_pr.py::TestChangedFiles::test_get_changed_files -v`
Expected: FAIL with "cannot import name 'get_changed_files'"

**Step 3: Write minimal implementation**

Add to `src/repo2ai/pr.py`:

```python
from typing import Optional, Set


def get_changed_files(
    repo_root: Path,
    target_branch: str,
) -> Set[Path]:
    """
    Get files changed between current branch and target branch.

    Args:
        repo_root: Path to repository root
        target_branch: Branch to compare against

    Returns:
        Set of absolute file paths that changed
    """
    try:
        result = subprocess.run(
            ["git", "diff", "--name-only", f"{target_branch}...HEAD"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True,
        )

        files = set()
        for line in result.stdout.strip().split("\n"):
            if line:
                file_path = repo_root / line
                if file_path.exists():
                    files.add(file_path)

        return files
    except subprocess.CalledProcessError:
        return set()
```

**Step 4: Run test to verify it passes**

Run: `poetry run pytest tests/test_pr.py::TestChangedFiles -v`
Expected: PASS

---

## Task 4: Add PR Context Dataclass and Generator

**Files:**
- Modify: `src/repo2ai/pr.py`
- Modify: `tests/test_pr.py`

**Step 1: Write the failing test**

Add to `tests/test_pr.py`:

```python
from repo2ai.pr import (
    get_target_branch,
    get_branch_diff,
    get_changed_files,
    PRContext,
    get_pr_context,
)


class TestPRContext(TestCase):
    """Test PR context generation."""

    def setUp(self):
        """Create a temporary git repository with branches."""
        self.temp_dir = tempfile.mkdtemp()
        self.repo_root = Path(self.temp_dir)

        # Initialize git repo
        subprocess.run(["git", "init", "-b", "main"], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "config", "user.email", "test@test.com"],
            cwd=self.repo_root,
            capture_output=True,
        )
        subprocess.run(
            ["git", "config", "user.name", "Test"],
            cwd=self.repo_root,
            capture_output=True,
        )

        # Create initial commit on main
        (self.repo_root / "file.py").write_text("# original\n")
        subprocess.run(["git", "add", "."], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "Initial commit"],
            cwd=self.repo_root,
            capture_output=True,
        )

        # Create feature branch
        subprocess.run(
            ["git", "checkout", "-b", "my-feature"],
            cwd=self.repo_root,
            capture_output=True,
        )
        (self.repo_root / "file.py").write_text("# modified\n")
        subprocess.run(["git", "add", "."], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "My feature"],
            cwd=self.repo_root,
            capture_output=True,
        )

    def tearDown(self):
        """Clean up temporary directory."""
        import shutil
        shutil.rmtree(self.temp_dir)

    def test_get_pr_context(self):
        """Test getting full PR context."""
        context = get_pr_context(self.repo_root, target_branch=None)

        self.assertEqual(context.current_branch, "my-feature")
        self.assertEqual(context.target_branch, "main")
        self.assertIn("+# modified", context.diff)
        self.assertEqual(len(context.changed_files), 1)
```

**Step 2: Run test to verify it fails**

Run: `poetry run pytest tests/test_pr.py::TestPRContext::test_get_pr_context -v`
Expected: FAIL with "cannot import name 'PRContext'"

**Step 3: Write minimal implementation**

Add to `src/repo2ai/pr.py`:

```python
from dataclasses import dataclass
from typing import List, Optional, Set


@dataclass
class PRContext:
    """Context for PR review."""

    current_branch: str
    target_branch: str
    diff: str
    changed_files: Set[Path]
    commit_count: int


def get_current_branch(repo_root: Path) -> str:
    """Get the current branch name."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return "unknown"


def get_commit_count(repo_root: Path, target_branch: str) -> int:
    """Get number of commits between target and HEAD."""
    try:
        result = subprocess.run(
            ["git", "rev-list", "--count", f"{target_branch}...HEAD"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True,
        )
        return int(result.stdout.strip())
    except (subprocess.CalledProcessError, ValueError):
        return 0


def get_pr_context(
    repo_root: Path,
    target_branch: Optional[str] = None,
) -> PRContext:
    """
    Get full PR context for review.

    Args:
        repo_root: Path to repository root
        target_branch: Optional explicit target branch

    Returns:
        PRContext with all review information
    """
    target = get_target_branch(repo_root, target_branch)
    current = get_current_branch(repo_root)

    return PRContext(
        current_branch=current,
        target_branch=target,
        diff=get_branch_diff(repo_root, target),
        changed_files=get_changed_files(repo_root, target),
        commit_count=get_commit_count(repo_root, target),
    )
```

**Step 4: Run test to verify it passes**

Run: `poetry run pytest tests/test_pr.py::TestPRContext -v`
Expected: PASS

---

## Task 5: Add PR Markdown Generator

**Files:**
- Modify: `src/repo2ai/pr.py`
- Modify: `tests/test_pr.py`

**Step 1: Write the failing test**

Add to `tests/test_pr.py`:

```python
from repo2ai.pr import (
    get_target_branch,
    get_branch_diff,
    get_changed_files,
    PRContext,
    get_pr_context,
    generate_pr_markdown,
)


class TestPRMarkdown(TestCase):
    """Test PR markdown generation."""

    def test_generate_pr_markdown(self):
        """Test markdown generation from PR context."""
        context = PRContext(
            current_branch="feature-x",
            target_branch="main",
            diff="--- a/file.py\n+++ b/file.py\n@@ -1 +1 @@\n-old\n+new",
            changed_files={Path("/repo/file.py")},
            commit_count=2,
        )

        # Mock file content
        markdown = generate_pr_markdown(
            context,
            file_contents={"file.py": "# new content"},
        )

        # Check structure
        self.assertIn("# PR Review: feature-x → main", markdown)
        self.assertIn("## Summary", markdown)
        self.assertIn("Branch: `feature-x`", markdown)
        self.assertIn("Target: `main`", markdown)
        self.assertIn("Commits: 2", markdown)
        self.assertIn("## Diff", markdown)
        self.assertIn("```diff", markdown)
        self.assertIn("+new", markdown)
        self.assertIn("## Changed Files", markdown)
        self.assertIn("### file.py", markdown)
```

**Step 2: Run test to verify it fails**

Run: `poetry run pytest tests/test_pr.py::TestPRMarkdown::test_generate_pr_markdown -v`
Expected: FAIL with "cannot import name 'generate_pr_markdown'"

**Step 3: Write minimal implementation**

Add to `src/repo2ai/pr.py`:

```python
from typing import Dict


def generate_pr_markdown(
    context: PRContext,
    file_contents: Dict[str, str],
) -> str:
    """
    Generate annotated markdown for PR review.

    Args:
        context: PR context with diff and metadata
        file_contents: Dict mapping relative paths to file contents

    Returns:
        Formatted markdown string
    """
    lines = []

    # Header
    lines.append(f"# PR Review: {context.current_branch} → {context.target_branch}")
    lines.append("")

    # Summary section
    lines.append("## Summary")
    lines.append("")
    lines.append(f"- **Branch:** `{context.current_branch}`")
    lines.append(f"- **Target:** `{context.target_branch}`")
    lines.append(f"- **Changed files:** {len(context.changed_files)}")
    lines.append(f"- **Commits:** {context.commit_count}")
    lines.append("")

    # Diff section
    lines.append("## Diff")
    lines.append("")
    lines.append("*This shows exactly what changed. Review for correctness, style, and potential issues.*")
    lines.append("")
    lines.append("```diff")
    lines.append(context.diff)
    lines.append("```")
    lines.append("")

    # Changed files section
    lines.append("## Changed Files (Full Context)")
    lines.append("")
    lines.append("*Full content of changed files for understanding the broader context.*")
    lines.append("")

    for rel_path, content in sorted(file_contents.items()):
        lines.append(f"### {rel_path}")
        lines.append("")

        # Detect language from extension
        ext = Path(rel_path).suffix.lower()
        lang_map = {
            ".py": "python",
            ".js": "javascript",
            ".ts": "typescript",
            ".md": "markdown",
            ".json": "json",
            ".yaml": "yaml",
            ".yml": "yaml",
        }
        lang = lang_map.get(ext, "")

        lines.append(f"```{lang}")
        lines.append(content)
        lines.append("```")
        lines.append("")

    return "\n".join(lines)
```

**Step 4: Run test to verify it passes**

Run: `poetry run pytest tests/test_pr.py::TestPRMarkdown -v`
Expected: PASS

---

## Task 6: Add --pr-review CLI Argument

**Files:**
- Modify: `src/repo2ai/cli.py`
- Modify: `tests/test_cli.py`

**Step 1: Write the failing test**

Add to `tests/test_cli.py`:

```python
class TestPRReviewArgument(TestCase):
    """Test --pr-review CLI argument."""

    def test_pr_review_flag(self):
        """Test --pr-review flag without target."""
        parser = create_parser()
        args = parser.parse_args([".", "--pr-review"])

        self.assertTrue(args.pr_review)
        self.assertIsNone(args.pr_target)

    def test_pr_review_with_target(self):
        """Test --pr-review with explicit target."""
        parser = create_parser()
        args = parser.parse_args([".", "--pr-review", "--pr-target", "develop"])

        self.assertTrue(args.pr_review)
        self.assertEqual(args.pr_target, "develop")

    def test_pr_review_implies_clipboard(self):
        """Test --pr-review defaults to clipboard."""
        parser = create_parser()
        args = parser.parse_args([".", "--pr-review"])

        # pr_review should be True, clipboard handling in main()
        self.assertTrue(args.pr_review)
```

**Step 2: Run test to verify it fails**

Run: `poetry run pytest tests/test_cli.py::TestPRReviewArgument::test_pr_review_flag -v`
Expected: FAIL with "unrecognized arguments: --pr-review"

**Step 3: Write minimal implementation**

Modify `src/repo2ai/cli.py` - add after scope options:

```python
    # PR Review options
    pr_group = parser.add_argument_group("PR review options")
    pr_group.add_argument(
        "--pr-review",
        action="store_true",
        help="Generate PR review context (diff + changed files) for AI review",
    )
    pr_group.add_argument(
        "--pr-target",
        metavar="BRANCH",
        help="Target branch for PR comparison (default: auto-detect or 'main')",
    )
```

**Step 4: Run test to verify it passes**

Run: `poetry run pytest tests/test_cli.py::TestPRReviewArgument -v`
Expected: PASS

---

## Task 7: Wire Up PR Review in Main Function

**Files:**
- Modify: `src/repo2ai/cli.py`
- Modify: `tests/test_cli.py`

**Step 1: Write the failing test**

Add to `tests/test_cli.py`:

```python
class TestPRReviewIntegration(TestCase):
    """Test PR review integration."""

    def setUp(self):
        """Create a temporary git repository with branches."""
        self.temp_dir = tempfile.mkdtemp()
        self.repo_root = Path(self.temp_dir)

        # Initialize git repo
        subprocess.run(["git", "init", "-b", "main"], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "config", "user.email", "test@test.com"],
            cwd=self.repo_root,
            capture_output=True,
        )
        subprocess.run(
            ["git", "config", "user.name", "Test"],
            cwd=self.repo_root,
            capture_output=True,
        )

        # Create initial commit
        (self.repo_root / "file.py").write_text("# original\n")
        subprocess.run(["git", "add", "."], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "Initial"],
            cwd=self.repo_root,
            capture_output=True,
        )

        # Create feature branch
        subprocess.run(
            ["git", "checkout", "-b", "feature"],
            cwd=self.repo_root,
            capture_output=True,
        )
        (self.repo_root / "file.py").write_text("# modified\n")
        subprocess.run(["git", "add", "."], cwd=self.repo_root, capture_output=True)
        subprocess.run(
            ["git", "commit", "-m", "Feature"],
            cwd=self.repo_root,
            capture_output=True,
        )

    def tearDown(self):
        """Clean up."""
        import shutil
        shutil.rmtree(self.temp_dir)

    @patch("repo2ai.cli.handle_output")
    def test_pr_review_generates_markdown(self, mock_output):
        """Test --pr-review generates proper markdown."""
        test_args = ["repo2ai", str(self.repo_root), "--pr-review", "--stdout"]

        with patch("sys.argv", test_args):
            main()

        # Check that output was called with PR-style markdown
        mock_output.assert_called_once()
        markdown = mock_output.call_args[0][0]
        self.assertIn("# PR Review:", markdown)
        self.assertIn("## Diff", markdown)
        self.assertIn("## Changed Files", markdown)
```

Add import at top of test file:
```python
import subprocess
```

**Step 2: Run test to verify it fails**

Run: `poetry run pytest tests/test_cli.py::TestPRReviewIntegration::test_pr_review_generates_markdown -v`
Expected: FAIL (pr_review not wired up in main)

**Step 3: Write minimal implementation**

Modify `src/repo2ai/cli.py` - add import at top:

```python
from .pr import get_pr_context, generate_pr_markdown
```

Modify `main()` function - add after `scope_config = build_scope_config(args)`:

```python
    # Handle PR review mode
    if args.pr_review:
        try:
            print("Generating PR review context...", file=sys.stderr)
            pr_context = get_pr_context(Path(args.path).resolve(), args.pr_target)

            if not pr_context.diff:
                print("No changes found between branches.", file=sys.stderr)
                sys.exit(0)

            # Read changed file contents
            file_contents = {}
            for file_path in pr_context.changed_files:
                try:
                    rel_path = file_path.relative_to(Path(args.path).resolve())
                    with open(file_path, "r", encoding="utf-8") as f:
                        file_contents[str(rel_path)] = f.read()
                except (IOError, UnicodeDecodeError):
                    pass

            markdown_content = generate_pr_markdown(pr_context, file_contents)

            # Default to clipboard for PR review
            if not args.output and not args.stdout:
                args.clipboard = True

            handle_output(
                markdown_content,
                output_file=args.output,
                use_clipboard=args.clipboard,
                use_stdout=args.stdout,
            )

            # Handle AI chat
            if args.open_chat:
                open_ai_chat(args.open_chat, args.prompt, args.browser)
            elif args.chat_all:
                for service in ["chatgpt", "claude", "gemini"]:
                    open_ai_chat(service, args.prompt, args.browser)

            return
        except Exception as e:
            print(f"Error generating PR review: {e}", file=sys.stderr)
            sys.exit(1)
```

**Step 4: Run test to verify it passes**

Run: `poetry run pytest tests/test_cli.py::TestPRReviewIntegration -v`
Expected: PASS

---

## Task 8: Export PR Module from Package

**Files:**
- Modify: `src/repo2ai/__init__.py`

**Step 1: Update __init__.py**

Add to imports:

```python
from .pr import (
    PRContext,
    get_pr_context,
    get_target_branch,
    get_branch_diff,
    get_changed_files,
    generate_pr_markdown,
)
```

Add to `__all__`:

```python
    "PRContext",
    "get_pr_context",
    "get_target_branch",
    "get_branch_diff",
    "get_changed_files",
    "generate_pr_markdown",
```

**Step 2: Run all tests**

Run: `poetry run pytest tests/ -v`
Expected: All tests pass

---

## Task 9: Update CLI Help and Documentation

**Files:**
- Modify: `src/repo2ai/cli.py` (epilog)
- Modify: `README.md`

**Step 1: Update CLI epilog**

Add to epilog in `create_parser()`:

```
PR review (AI-assisted code review):
  repo2ai . --pr-review                       # Review current branch vs main
  repo2ai . --pr-review --pr-target develop   # Review against develop
  repo2ai . --pr-review --open-chat claude    # Review and open Claude
```

**Step 2: Update README.md**

Add new section after "Scope Filtering":

```markdown
### PR Review

Generate context for AI-assisted PR review:

```bash
# Review current branch against main (copies to clipboard)
repo2ai . --pr-review

# Review against specific branch
repo2ai . --pr-review --pr-target develop

# Review and open Claude
repo2ai . --pr-review --open-chat claude --prompt "Review this PR for bugs and style issues"
```

The PR review output includes:
- Summary (branch names, file count, commit count)
- Full diff (what changed)
- Complete changed files (for context)
```

**Step 3: Run full test suite**

Run: `poetry run pytest tests/ -v`
Expected: All tests pass

---

## Task 10: Final Validation

**Step 1: Run CI checks**

Run: `make ci`
Expected: All checks pass (format, lint, test)

**Step 2: Manual test**

```bash
# Create a test branch and try it
git checkout -b test-pr-review
echo "# test" > test_file.py
git add test_file.py
git commit -m "Test commit"

# Run PR review
poetry run repo2ai . --pr-review --stdout

# Cleanup
git checkout main
git branch -D test-pr-review
```

**Step 3: Verify output structure**

Expected output should have:
- `# PR Review: test-pr-review → main`
- `## Summary` with branch info
- `## Diff` with actual diff
- `## Changed Files` with full content

---

## Task 11: Add Pre-commit Configuration

**Files:**
- Create: `.pre-commit-config.yaml`

**Step 1: Create pre-commit config**

```yaml
# .pre-commit-config.yaml
repos:
  - repo: local
    hooks:
      - id: black
        name: black
        entry: poetry run black
        language: system
        types: [python]
        args: [--check]
      - id: flake8
        name: flake8
        entry: poetry run flake8
        language: system
        types: [python]
      - id: mypy
        name: mypy
        entry: poetry run mypy
        language: system
        types: [python]
        args: [src/repo2ai]
        pass_filenames: false
```

**Step 2: Install pre-commit hooks**

Run: `pre-commit install`
Expected: "pre-commit installed at .git/hooks/pre-commit"

**Step 3: Test the hooks**

Run: `pre-commit run --all-files`
Expected: All hooks pass (black, flake8, mypy)

---

## Summary

| Task | Description | Files |
|------|-------------|-------|
| 1 | Branch detection | `pr.py`, `test_pr.py` |
| 2 | Diff generation | `pr.py`, `test_pr.py` |
| 3 | Changed files list | `pr.py`, `test_pr.py` |
| 4 | PRContext dataclass | `pr.py`, `test_pr.py` |
| 5 | Markdown generator | `pr.py`, `test_pr.py` |
| 6 | CLI argument | `cli.py`, `test_cli.py` |
| 7 | Wire up in main | `cli.py`, `test_cli.py` |
| 8 | Package exports | `__init__.py` |
| 9 | Help and docs | `cli.py`, `README.md` |
| 10 | Final validation | - |
| 11 | Pre-commit config | `.pre-commit-config.yaml` |
